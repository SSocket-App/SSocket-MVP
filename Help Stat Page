// App.js — single-file Expo Snack. No extra deps (uses only @expo/vector-icons which Snack provides)
import React, { useMemo, useState } from "react";
import {
  SafeAreaView,
  StatusBar,
  View,
  Text,
  ScrollView,
  StyleSheet,
  Platform,
  TouchableOpacity,
  Dimensions,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";

/* ===== Brand ===== */
const BLACK = "#000";
const WHITE = "#FFF";
const YELLOW = "#FFD54A";
const TOP_BAR_HEIGHT = 88;
const TOP_ACCENT = 3;

/* ===== PRNG + Mock HELP data ===== */
function prng(n) { const x = Math.sin(n) * 10000; return x - Math.floor(x); }

function buildDaily(seed = 1, days = 90) {
  const arr = [];
  const now = new Date();
  for (let i = days - 1; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(now.getDate() - i);
    const k = Number(`${d.getFullYear()}${d.getMonth()+1}${d.getDate()}`) * seed;
    const helps = Math.max(0, Math.round(prng(k) * 4 + (d.getDay() % 2)));
    const base = 3.6 + prng(k + 7) * 1.2;
    const rating = helps ? Math.min(5, base + Math.min(0.5, helps * 0.06)) : 0;
    const winBias = Math.max(0, (rating - 3.5) / 1.5);
    const winRate = 0.25 + 0.5 * winBias * (0.8 + 0.4 * prng(k + 13));
    const wins = Math.min(helps, Math.round(helps * winRate));
    arr.push({ date: d, label: `${d.getDate()}/${d.getMonth()+1}`, helps, rating: Number(rating.toFixed(2)), wins, attempts: helps });
  }
  return arr;
}
function buildActiveMap(ratio = 0.75) {
  const len = 14, activeCount = Math.round(len * ratio);
  const arr = Array(len).fill(false);
  for (let i = 0; i < activeCount; i++) arr[i] = true;
  for (let i = 0; i < len; i++) {
    const j = Math.floor(prng((i + 1) * 999) * len);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

const NICHE_KEYS = ["All", "Mechanical", "Software", "Marketing", "Design"];
const DATA = {
  All: {
    totalReviews: 86, avgRating: 4.7, wins: 18, attempts: 50, consistency: 0.78,
    posTags: { Creative: 72, Clear: 65, Practical: 59, Fast: 61, Helpful: 53, Analytical: 48 },
    improve: { "More Detail": 39, "Simpler Language": 24, "Real Example": 18, "Step-by-Step": 15, "Practical Solution": 12, "Clear Format": 10, "Accurate Information": 9 },
    negFlags: { Unclear: 12, "Overly Brief": 9, Impractical: 7 },
    categories: { Tech: 52, Design: 28, Marketing: 20 },
    daily: buildDaily(1),
    activeMap: buildActiveMap(0.78),
  },
  Mechanical: {
    totalReviews: 31, avgRating: 4.6, wins: 9, attempts: 31, consistency: 0.74,
    posTags: { Practical: 22, Analytical: 19, Clear: 16, Helpful: 14, Creative: 11, Fast: 10 },
    improve: { "More Detail": 14, "Real Example": 9, "Step-by-Step": 8, "Accurate Information": 6, "Practical Solution": 5, "Clear Format": 4, "Simpler Language": 3 },
    negFlags: { Unclear: 5, "Overly Brief": 4, Impractical: 3 },
    categories: { Mechanical: 70, Manufacturing: 20, Maintenance: 10 },
    daily: buildDaily(2),
    activeMap: buildActiveMap(0.74),
  },
  Software: {
    totalReviews: 28, avgRating: 4.8, wins: 10, attempts: 29, consistency: 0.81,
    posTags: { Analytical: 20, Clear: 18, Practical: 15, Fast: 15, Helpful: 12, Creative: 10 },
    improve: { "More Detail": 9, "Clear Format": 7, "Step-by-Step": 7, "Accurate Information": 5, "Real Example": 4, "Practical Solution": 4, "Simpler Language": 3 },
    negFlags: { Unclear: 3, "Overly Brief": 3, Impractical: 2 },
    categories: { Backend: 40, Frontend: 35, DevOps: 25 },
    daily: buildDaily(3),
    activeMap: buildActiveMap(0.81),
  },
  Marketing: {
    totalReviews: 17, avgRating: 4.5, wins: 5, attempts: 19, consistency: 0.70,
    posTags: { Creative: 16, Clear: 12, Practical: 10, Helpful: 9, Analytical: 8, Fast: 7 },
    improve: { "More Detail": 6, "Real Example": 5, "Simpler Language": 4, "Practical Solution": 4, "Clear Format": 3, "Step-by-Step": 2, "Accurate Information": 2 },
    negFlags: { Unclear: 2, "Overly Brief": 2, Impractical: 1 },
    categories: { Content: 45, Growth: 35, Brand: 20 },
    daily: buildDaily(4),
    activeMap: buildActiveMap(0.7),
  },
  Design: {
    totalReviews: 10, avgRating: 4.6, wins: 4, attempts: 13, consistency: 0.73,
    posTags: { Creative: 12, Clear: 8, Practical: 7, Helpful: 6, Fast: 5, Analytical: 4 },
    improve: { "More Detail": 4, "Clear Format": 3, "Real Example": 2, "Step-by-Step": 2, "Practical Solution": 2, "Simpler Language": 2, "Accurate Information": 1 },
    negFlags: { Unclear: 1, "Overly Brief": 1, Impractical: 0 },
    categories: { UI: 55, UX: 30, Branding: 15 },
    daily: buildDaily(5),
    activeMap: buildActiveMap(0.73),
  },
};

/* ===== Utils ===== */
const sumVals = (obj) => Object.values(obj).reduce((a, b) => a + b, 0);
const W = Dimensions.get("window").width;
const pad2 = (n) => (n < 10 ? `0${n}` : `${n}`);
const fmt = (dt) => `${pad2(dt.getDate())}/${pad2(dt.getMonth()+1)}/${dt.getFullYear()}`;

/* === STAR DISTRIBUTION (realistic, interval-aware) === */
function mergeCounts(acc, add) { for (let s = 1; s <= 5; s++) acc[s] = (acc[s] || 0) + (add[s] || 0); return acc; }
function roundPreserve(total, floats, seedBase = 0) {
  const floors = floats.map(Math.floor);
  let rem = total - floors.reduce((a,b)=>a+b,0);
  const order = floats.map((v,i)=>({i, r:v - floors[i]}))
                      .sort((a,b)=> b.r - a.r || prng(seedBase + a.i) - prng(seedBase + b.i));
  const out = floors.slice();
  for (let j = 0; j < rem; j++) out[order[j].i]++;
  return out;
}
function dayStarCountsRealistic(day, seed = 0) {
  if (day.starCounts) { const safe = {1:0,2:0,3:0,4:0,5:0, ...day.starCounts}; return safe; }
  if (Array.isArray(day.ratings)) {
    const c = {1:0,2:0,3:0,4:0,5:0};
    day.ratings.forEach(v => { if (v>=1 && v<=5) c[v]++; });
    return c;
  }
  const h = Math.max(0, day.helps || 0);
  if (!h) return {1:0,2:0,3:0,4:0,5:0};
  const r = Math.max(1, Math.min(5, day.rating || 3.5));
  const sigma = 1.0 - Math.min(0.6, Math.log10(Math.max(1, h)) * 0.25);
  const weights = [1,2,3,4,5].map((s, i) => {
    const base = Math.exp(-Math.pow(s - r, 2) / (2 * sigma * sigma));
    const jitter = 0.9 + 0.2 * prng(seed + i);
    return base * jitter;
  });
  const sumW = weights.reduce((a,b)=>a+b,0) || 1;
  const probs = weights.map(w => w / sumW);
  const floats = probs.map(p => p * h);
  const [c1,c2,c3,c4,c5] = roundPreserve(h, floats, seed);
  return {1:c1,2:c2,3:c3,4:c4,5:c5};
}
function distForRange(days) {
  return days.reduce((acc, p, idx) => {
    const counts = dayStarCountsRealistic(p, (p.date?.getTime?.() || idx) + idx);
    return mergeCounts(acc, counts);
  }, {1:0,2:0,3:0,4:0,5:0});
}

/* === Interval-based GREEN strengths — return COUNTS (integers) === */
function strengthsFromInterval(inRange, d) {
  const base = {
    Creative: d.posTags.Creative || 40,
    Analytical: d.posTags.Analytical || 40,
    Practical: d.posTags.Practical || 40,
    Detailed: (d.posTags.Clear || 30) + (d.posTags.Fast || 0) * 0.2,
    Helpful: d.posTags.Helpful || 35,
    Insightful: (d.posTags.Clear || 25) + (d.posTags.Creative || 0) * 0.3,
    Innovative: (d.posTags.Creative || 25) + (d.posTags.Analytical || 0) * 0.2,
    Professional: (d.posTags.Clear || 25) + 20,
  };
  const keys = Object.keys(base);
  const totalBase = keys.reduce((a,k)=>a+base[k],0) || 1;
  const counts = Object.fromEntries(keys.map(k=>[k,0]));
  inRange.forEach((p, idx) => {
    const h = p.helps || 0;
    keys.forEach((k, i) => {
      const jitter = 0.9 + 0.2 * prng(h + base[k] + i + idx);
      counts[k] += (h * (base[k] / totalBase)) * jitter;
    });
  });
  keys.forEach(k => { counts[k] = Math.max(0, Math.round(counts[k])); });
  return counts;
}

/* === Interval-based RED reasons — return COUNTS (integers) === */
function improveFromInterval(inRange, d) {
  const base = {
    "Undetailed explanation": (d.improve["More Detail"] || 0),
    "Overcomplicated": (d.improve["Simpler Language"] || 0) + (d.improve["Clear Format"] || 0),
    "Unconcreted illustration": (d.improve["Real Example"] || 0),
    "Unclear solution": (d.negFlags.Unclear || 0),
    "Not actionable": (d.improve["Practical Solution"] || 0),
    "Messy explanation": (d.improve["Clear Format"] || 0) + (d.negFlags["Overly Brief"] || 0),
    "Misleading fact": (d.improve["Accurate Information"] || 0),
  };
  const reasons = Object.keys(base);
  const weightSum = reasons.reduce((a,k)=>a+base[k],0) || 1;
  const counts = Object.fromEntries(reasons.map(k=>[k,0]));
  inRange.forEach((p, idx) => {
    const dist = dayStarCountsRealistic(p, idx);
    const notFive = (p.helps || 0) - (dist[5] || 0);
    reasons.forEach((k, i) => {
      const jitter = 0.9 + 0.2 * prng(notFive + base[k] + i + idx);
      counts[k] += (notFive * (base[k] / weightSum)) * jitter;
    });
  });
  reasons.forEach(k => { counts[k] = Math.max(0, Math.round(counts[k])); });
  return counts;
}

/* ===== High-contrast palette + mapping ===== */
const CATEGORY10 = [
  "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
  "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
];
function colorMapForList(keys, offset = 0) {
  const map = {};
  keys.forEach((k, i) => { map[k] = CATEGORY10[(i + offset) % CATEGORY10.length]; });
  return map;
}

/* ===== UI bits ===== */
function TitleRow({ title, help }) {
  const [open, setOpen] = useState(false);
  return (
    <View style={{ marginBottom: open ? 8 : 0 }}>
      <View style={styles.titleRow}>
        <Text style={styles.cardTitle}>{title}</Text>
        <TouchableOpacity
          onPress={() => setOpen((v) => !v)}
          activeOpacity={0.85}
          style={styles.infoBtn}
          hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}
        >
          <Text style={styles.infoTxt}>i</Text>
        </TouchableOpacity>
      </View>
      {open && (
        <View style={styles.helpBox}>
          <Text style={styles.helpText}>{help}</Text>
        </View>
      )}
    </View>
  );
}
function Card({ children }) { return <View style={styles.card}>{children}</View>; }
function Chip({ text, active, onPress }) {
  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.9}
      style={[styles.chip, active && { backgroundColor: "#FFFDF2", borderColor: YELLOW }]}
    >
      <Text style={styles.chipTxt}>{text}</Text>
    </TouchableOpacity>
  );
}
function StarsInline({ value = 0 }) {
  const v = Math.max(0, Math.min(5, Number(value) || 0));
  const full = Math.floor(v);
  const half = v - full >= 0.5;
  const stars = "★".repeat(full) + (half ? "★" : "") + "☆".repeat(5 - full - (half ? 1 : 0));
  return (
    <View style={styles.starRow}>
      <Text style={styles.starVal}>{stars} {v.toFixed(1)}★</Text>
    </View>
  );
}
function HBar({ label, pct, big = false, color = YELLOW }) {
  const widthPct = `${Math.max(4, Math.min(100, pct || 0))}%`;
  return (
    <View style={styles.hbarRow}>
      <View style={[styles.hbarLabelWrap, big && { width: 180 }]}>
        <View style={[styles.legendSwatch, { backgroundColor: color }]} />
        <Text style={styles.hbarLabel} numberOfLines={1}>{label}</Text>
      </View>
      <View style={[styles.hbarTrack, big && { height: 20 }]}>
        <View style={[styles.hbarFill, { width: widthPct, backgroundColor: color }]} />
      </View>
      <Text style={styles.hbarPct}>{Math.round(pct || 0)}%</Text>
    </View>
  );
}

/* === Pure-View PIE CHART (no libraries) === */
function PieChart({ data = [], size = 160, startAtTop = true }) {
  const total = data.reduce((a, b) => a + (Number.isFinite(b.value) ? b.value : 0), 0) || 1;
  const radius = size / 2;
  const thickness = radius; // full pie
  let accAngle = startAtTop ? -90 : 0;

  return (
    <View style={{ alignItems: "center", marginTop: 8 }}>
      <View style={[styles.pieBox, { width: size, height: size }]}>
        <View style={[styles.pieTrack, { width: size, height: size, borderRadius: radius }]} />
        {data.map((slice, i) => {
          const v = Math.max(0, Number(slice.value) || 0);
          const angle = (v / total) * 360;
          if (angle <= 0.001) return null;
          const start = accAngle;
          accAngle += angle;
          const rightAngle = Math.min(angle, 180);
          const leftAngle  = Math.max(angle - 180, 0);
          return (
            <View
              key={`${slice.label}-${i}`}
              style={[styles.sliceWrap, { width: size, height: size, transform: [{ rotateZ: `${start}deg` }] }]}
            >
              <View style={[styles.halfWrap, { width: radius, height: size, right: radius }]}>
                <View
                  style={[
                    styles.sliceArc,
                    {
                      width: size,
                      height: size,
                      borderRadius: radius,
                      borderWidth: thickness,
                      transform: [{ rotateZ: `${rightAngle}deg` }],
                      borderColor: slice.color,
                    },
                  ]}
                />
              </View>
              <View style={[styles.halfWrap, { width: radius, height: size, left: radius }]}>
                <View
                  style={[
                    styles.sliceArc,
                    {
                      width: size,
                      height: size,
                      borderRadius: radius,
                      borderWidth: thickness,
                      transform: [{ rotateZ: `${leftAngle}deg` }],
                      borderColor: slice.color,
                      opacity: angle > 180 ? 1 : 0,
                    },
                  ]}
                />
              </View>
            </View>
          );
        })}
      </View>
    </View>
  );
}

/* === Simple hollow ring gauge (like your Competition stat page) === */
function GaugeRing({ pct, color, label }) {
  return (
    <View style={styles.gaugeBox}>
      <View style={[styles.gaugeCircle, { borderColor: color }]}>
        <Text style={styles.gaugeVal}>{Math.max(0, Math.min(100, Math.round(pct || 0)))}%</Text>
      </View>
      <Text style={styles.gaugeLabel}>{label}</Text>
    </View>
  );
}

/* ===== Main Page ===== */
export default function App() {
  const [niche, setNiche] = useState("All");

  const d = DATA[niche];
  const all = d.daily;

  // Date interval
  const [startIdx, setStartIdx] = useState(Math.max(0, all.length - 14));
  const [endIdx, setEndIdx] = useState(all.length - 1);
  const inRange = useMemo(() => all.slice(startIdx, endIdx + 1), [all, startIdx, endIdx]);

  const shiftStart = (dir) => setStartIdx((s) => Math.min(endIdx, Math.max(0, s + dir)));
  const shiftEnd   = (dir) => setEndIdx((e) => Math.max(startIdx, Math.min(all.length - 1, e + dir)));

  /* === Toggles === */
  const [ratingDistScope, setRatingDistScope] = useState("interval"); // 'interval' | 'all'
  const [winScope, setWinScope] = useState("interval");
  const [podiumScope, setPodiumScope] = useState("interval");
  const [consScope, setConsScope] = useState("interval");
  const [greenScope, setGreenScope] = useState("interval");
  const [redScope, setRedScope] = useState("interval");
  const [proofScope, setProofScope] = useState("interval");
  const [catScope, setCatScope] = useState("interval");

  // Interval totals
  const interval = useMemo(() => {
    const helps = inRange.reduce((a,b)=>a+b.helps,0);
    const gainedStars = inRange.reduce((a,b)=>a + Math.round(b.rating * b.helps),0);
    const possibleStars = inRange.reduce((a,b)=>a + b.helps*5,0);
    const wins = inRange.reduce((a,b)=>a + b.wins,0);
    const attempts = inRange.reduce((a,b)=>a + b.attempts,0);
    const dist = distForRange(inRange);
    const activeDays = inRange.filter(p => p.helps > 0).length;
    const totalDays = inRange.length;
    const avgPerHelp = helps ? (gainedStars / helps) : 0;

    const last14 = inRange.slice(-14);
    const consMap = Array(14).fill(false);
    const start = Math.max(0, 14 - last14.length);
    for (let i = 0; i < last14.length; i++) consMap[start + i] = (last14[i].helps || 0) > 0;

    return { helps, gainedStars, possibleStars, wins, attempts, dist, activeDays, totalDays, avgPerHelp, consMap };
  }, [inRange]);

  // All-time totals
  const allTime = useMemo(() => {
    const helps = all.reduce((a,b)=>a+b.helps,0);
    const gainedStars = all.reduce((a,b)=>a + Math.round(b.rating * b.helps),0);
    const possibleStars = all.reduce((a,b)=>a + b.helps*5,0);
    const wins = all.reduce((a,b)=>a + b.wins,0);
    const attempts = all.reduce((a,b)=>a + b.attempts,0);
    const dist = distForRange(all);
    const activeDays = all.filter(p => p.helps > 0).length;
    const totalDays = all.length;
    const avgPerHelp = helps ? (gainedStars / helps) : 0;

    return { helps, gainedStars, possibleStars, wins, attempts, dist, activeDays, totalDays, avgPerHelp };
  }, [all]);

  // Green/Red data (now COUNTS)
  const greenInterval = useMemo(() => strengthsFromInterval(inRange, d), [inRange, d]);
  const greenAll = useMemo(() => strengthsFromInterval(all, d), [all, d]);
  const redInterval = useMemo(() => improveFromInterval(inRange, d), [inRange, d]);
  const redAll = useMemo(() => improveFromInterval(all, d), [all, d]);

  const catAllTotal = sumVals(d.categories);
  const catEntries = Object.entries(d.categories);

  // Distinct color maps per section
  const GREEN_KEYS = ["Creative","Analytical","Practical","Detailed","Helpful","Insightful","Innovative","Professional"];
  const RED_KEYS = ["Undetailed explanation","Overcomplicated","Unconcreted illustration","Unclear solution","Not actionable","Messy explanation","Misleading fact"];
  const greenColors = useMemo(() => colorMapForList(GREEN_KEYS, 0), []);
  const redColors   = useMemo(() => colorMapForList(RED_KEYS, 3), []); // different offset

  // Pie data (current scope) — values are COUNTS
  const greenMap = greenScope === "interval" ? greenInterval : greenAll;
  const redMap   = redScope === "interval" ? redInterval : redAll;
  const greenPie = GREEN_KEYS.map(k => ({ label: k, value: greenMap[k] || 0, color: greenColors[k] }))
                             .filter(s => s.value > 0);
  const redPie   = RED_KEYS.map(k => ({ label: k, value: redMap[k] || 0, color: redColors[k] }))
                           .filter(s => s.value > 0);

  const ToggleRow = ({ scope, setScope }) => (
    <View style={styles.toggleRow}>
      <TouchableOpacity
        style={[styles.toggleBtn, scope === "interval" && styles.toggleActive]}
        onPress={() => setScope("interval")}
        activeOpacity={0.9}
      >
        <Text style={[styles.toggleTxt, scope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
      </TouchableOpacity>
      <TouchableOpacity
        style={[styles.toggleBtn, scope === "all" && styles.toggleActive]}
        onPress={() => setScope("all")}
        activeOpacity={0.9}
      >
        <Text style={[styles.toggleTxt, scope === "all" && styles.toggleTxtActive]}>All-Time</Text>
      </TouchableOpacity>
    </View>
  );

  // --- Podium calculation (derived, simple) ---
  const podiumFromTotals = (wins, attempts) => {
    const safeAttempts = Math.max(0, attempts || 0);
    if (!safeAttempts) return { first: 0, second: 0, third: 0 };
    const first = Math.round((wins / safeAttempts) * 100);
    const remaining = Math.max(0, 100 - first);
    const second = Math.round(remaining * 0.6); // allocate 60% of non-wins to 2nd
    const third = Math.max(0, 100 - first - second); // remainder to 3rd
    return { first, second, third };
  };
  const podiumInterval = podiumFromTotals(interval.wins, interval.attempts);
  const podiumAll      = podiumFromTotals(allTime.wins,  allTime.attempts);

  const podium = podiumScope === "interval" ? podiumInterval : podiumAll;

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor={BLACK} />

      {/* Top bar */}
      <View style={styles.topBar}>
        <TouchableOpacity style={styles.backBtn} activeOpacity={0.7}>
          <Ionicons name="chevron-back" size={24} color={WHITE} />
        </TouchableOpacity>

        <View style={styles.headerCenter}>
          <View>
            <Text style={styles.name}>John Doe</Text>
            <Text style={styles.rank}>Level 5</Text>
          </View>
        </View>

        <View style={{ width: 40, height: 36 }} />
      </View>

      <View style={styles.topAccent} />

      <ScrollView contentContainerStyle={{ padding: 12, paddingBottom: 24 }}>
        {/* Niche */}
        <Card>
          <TitleRow title="Niche" help="Pick a field. All numbers below use only HELP data for that field." />
          <View style={styles.nicheRow}>
            {NICHE_KEYS.map((k) => (
              <Chip key={k} text={k} active={niche === k} onPress={() => setNiche(k)} />
            ))}
          </View>
        </Card>

        {/* RATING & DATA */}
        <Card>
          <TitleRow
            title="Rating and Data"
            help="Choose a date window. Then flip cards to see interval vs all-time."
          />

          {/* Date range pickers */}
          <View style={styles.rangeRow}>
            <Text style={styles.rangeLbl}>From</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => shiftStart(-1)}>
              <Ionicons name="chevron-back" size={16} color={BLACK} />
            </TouchableOpacity>
            <Text style={styles.rangeVal}>{fmt(all[startIdx].date)}</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => shiftStart(1)}>
              <Ionicons name="chevron-forward" size={16} color={BLACK} />
            </TouchableOpacity>
          </View>
          <View style={styles.rangeRow}>
            <Text style={styles.rangeLbl}>To</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => shiftEnd(-1)}>
              <Ionicons name="chevron-back" size={16} color={BLACK} />
            </TouchableOpacity>
            <Text style={styles.rangeVal}>{fmt(all[endIdx].date)}</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => shiftEnd(1)}>
              <Ionicons name="chevron-forward" size={16} color={BLACK} />
            </TouchableOpacity>
          </View>

          {/* SHARED toggle for Average Rating + Star Distribution */}
          <ToggleRow scope={ratingDistScope} setScope={setRatingDistScope} />

          {/* Average Rating (text stars) */}
          <View style={styles.kpiBlock}>
            <Text style={styles.kpiBlockTitle}>Average Rating</Text>
            <StarsInline
              value={
                ratingDistScope === "interval"
                  ? (interval.helps ? interval.gainedStars / interval.helps : 0)
                  : (allTime.helps ? allTime.gainedStars / allTime.helps : 0)
              }
            />
            <Text style={[styles.kpiHint, { marginTop: 6 }]}>
              Stars earned:{" "}
              <Text style={styles.bigStatInline}>
                {ratingDistScope === "interval" ? interval.gainedStars : allTime.gainedStars}
              </Text>{" "}
              / {ratingDistScope === "interval" ? interval.possibleStars : allTime.possibleStars}
            </Text>
            <Text style={styles.kpiHint}>
              Reviews overall: <Text style={styles.bigStatInline}>{d.totalReviews}</Text>
            </Text>
          </View>

          {/* Star Distribution — SAME toggle */}
          <View style={[styles.kpiBlock, { marginTop: 8 }]}>
            <Text style={styles.kpiBlockTitle}>Star Distribution</Text>
            {["5","4","3","2","1"].map(s => (
              <Text key={s} style={styles.kidRow}>
                {"⭐".repeat(Number(s)).padEnd(5," ")} = {(ratingDistScope === "interval" ? interval.dist : allTime.dist)[s]} helps
              </Text>
            ))}
            <Text style={styles.kpiHint}>
              Counts use real ratings when available; otherwise modeled per-day from average rating and helps.
            </Text>
          </View>

          {/* Win Rate */}
          <ToggleRow scope={winScope} setScope={setWinScope} />
          <View style={[styles.kpiBlock, { marginTop: 8 }]}>
            <Text style={styles.kpiBlockTitle}>Win Rate</Text>
            <Text style={styles.bigStat}>
              {(winScope === "interval" ? interval.wins : allTime.wins)}/
              {(winScope === "interval" ? interval.attempts : allTime.attempts)} (
              {(() => {
                const w = winScope === "interval" ? interval.wins : allTime.wins;
                const a = winScope === "interval" ? interval.attempts : allTime.attempts;
                return a ? Math.round((w / a) * 100) : 0;
              })()}
              %)
            </Text>
            <Text style={styles.kpiHint}>Chosen as the final solution / attempts.</Text>
          </View>

          {/* === Podium Rates (new, simple rings) === */}
          <ToggleRow scope={podiumScope} setScope={setPodiumScope} />
          <View style={[styles.kpiBlock, { marginTop: 8 }]}>
            <Text style={styles.kpiBlockTitle}>Podium Rates</Text>
            <View style={styles.kpiGrid3}>
              <GaugeRing pct={podium.first}  color={YELLOW}   label="1st Rate" />
              <GaugeRing pct={podium.second} color="#5EC3FF" label="2nd Rate" />
              <GaugeRing pct={podium.third}  color="#FF9354" label="3rd Rate" />
            </View>
            <Text style={styles.kpiHint}>
              % of total attempts that finished 1st/2nd/3rd in this window.
            </Text>
          </View>

          {/* Consistency strip */}
          <ToggleRow scope={consScope} setScope={setConsScope} />
          <View style={[styles.kpiBlock, { marginTop: 8 }]}>
            <Text style={styles.kpiBlockTitle}>Consistency (last 14 days)</Text>
            <View style={styles.consRow}>
              {(consScope === "interval" ? interval.consMap : DATA[niche].activeMap).map((on, i) => (
                <View key={i} style={[styles.consBox, on ? { backgroundColor: "#FFFDF2", borderColor: YELLOW } : null]} />
              ))}
            </View>
            <Text style={styles.kpiHint}>
              {Math.round((consScope === "interval" ? interval.activeDays/interval.totalDays : d.consistency) * 100)}% active days
              {consScope === "interval" ? " in this window" : " recently"}
            </Text>
          </View>
        </Card>

        {/* ===== Green Tags (Pie + legend with COUNTS) ===== */}
        <Card>
          <TitleRow
            title="Green Tags"
            help="What people liked most. Pie uses distinct, high-contrast colors."
          />
          <ToggleRow scope={greenScope} setScope={setGreenScope} />
          <PieChart data={greenPie} size={160} />
          <View style={styles.legendGrid}>
            {greenPie.map((s) => (
              <View key={`g-${s.label}`} style={styles.legendItem}>
                <View style={[styles.legendSwatch, { backgroundColor: s.color }]} />
                <Text style={styles.legendTxt} numberOfLines={1}>
                  {s.label} ({s.value} tags)
                </Text>
              </View>
            ))}
          </View>
        </Card>

        {/* ===== Red Tags (Pie + legend with COUNTS) ===== */}
        <Card>
          <TitleRow
            title="Red Tags"
            help="Top reasons people didn’t give 5★. Pie uses distinct, high-contrast colors."
          />
          <ToggleRow scope={redScope} setScope={setRedScope} />
          <PieChart data={redPie} size={160} />
          <View style={styles.legendGrid}>
            {redPie.map((s) => (
              <View key={`r-${s.label}`} style={styles.legendItem}>
                <View style={[styles.legendSwatch, { backgroundColor: s.color }]} />
                <Text style={styles.legendTxt} numberOfLines={1}>
                  {s.label} ({s.value} tags)
                </Text>
              </View>
            ))}
          </View>
        </Card>

        {/* Proof points */}
        <Card>
          <TitleRow
            title="Proof Points (for employers)"
            help="Straight-to-the-point outcomes for the selected period or all time."
          />
          <ToggleRow scope={proofScope} setScope={setProofScope} />
          <View style={styles.kpiGrid2}>
            <View style={styles.kpi}>
              <Text style={styles.kpiLabel}>Helps completed</Text>
              <Text style={styles.kpiValue}>{proofScope === "interval" ? interval.helps : allTime.helps}</Text>
              <Text style={styles.kpiHint}>Total solved requests</Text>
            </View>
            <View style={styles.kpi}>
              <Text style={styles.kpiLabel}>Avg ★ per help</Text>
              <Text style={styles.kpiValue}>
                {(proofScope === "interval" ? interval.avgPerHelp : allTime.avgPerHelp).toFixed(2)}
              </Text>
              <Text style={styles.kpiHint}>Quality per answer</Text>
            </View>
            <View style={styles.kpi}>
              <Text style={styles.kpiLabel}>On-duty days</Text>
              <Text style={styles.kpiValue}>
                {(proofScope === "interval" ? interval.activeDays : allTime.activeDays)}/
                {(proofScope === "interval" ? interval.totalDays : allTime.totalDays)}
              </Text>
              <Text style={styles.kpiHint}>Days you showed up and helped</Text>
            </View>
          </View>

          {/* Categories (proportional display) */}
          <ToggleRow scope={catScope} setScope={setCatScope} />
          <View style={{ marginTop: 10 }}>
            <Text style={[styles.sectionHint, { marginBottom: 4 }]}>Common problem types you help with</Text>
            {catEntries.map(([k, v]) => {
              const pct = Math.round((v / Math.max(1, catAllTotal)) * 100);
              return <HBar key={k} label={`• ${k}`} pct={pct} big color="#7f7f7f" />;
            })}
          </View>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
}

/* ===== Styles ===== */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: WHITE },

  /* Top bar */
  topBar: {
    backgroundColor: BLACK,
    height: TOP_BAR_HEIGHT,
    paddingTop: Platform.OS === "android" ? (StatusBar.currentHeight || 0) : 12,
    paddingHorizontal: 12,
    paddingBottom: 12,
    flexDirection: "row",
    alignItems: "flex-end",
    justifyContent: "space-between",
  },
  topAccent: { height: TOP_ACCENT, backgroundColor: YELLOW },
  backBtn: { width: 40, height: 36, justifyContent: "center" },

  headerCenter: { flexDirection: "row", alignItems: "center" },
  name: { color: WHITE, fontWeight: "900", fontSize: 16, lineHeight: 16 },
  rank: { color: "#DADADA", fontSize: 12, marginTop: 2 },

  /* Cards */
  card: { backgroundColor: WHITE, borderWidth: 2, borderColor: BLACK, borderRadius: 14, padding: 12, marginBottom: 12 },
  titleRow: { flexDirection: "row", justifyContent: "space-between", alignItems: "center" },
  cardTitle: { fontSize: 14, fontWeight: "900", color: BLACK },
  infoBtn: {
    width: 22, height: 22, borderRadius: 11,
    borderWidth: 2, borderColor: BLACK,
    alignItems: "center", justifyContent: "center", backgroundColor: WHITE,
  },
  infoTxt: { fontSize: 12, fontWeight: "900", color: BLACK },
  helpBox: { marginTop: 8, borderWidth: 2, borderColor: BLACK, borderRadius: 10, padding: 8, backgroundColor: "#FFFDF2" },
  helpText: { color: BLACK, fontSize: 12 },

  /* Niche row */
  nicheRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  chip: { paddingVertical: 6, paddingHorizontal: 10, borderRadius: 16, borderWidth: 2, borderColor: BLACK, backgroundColor: WHITE },
  chipTxt: { color: BLACK, fontSize: 12, fontWeight: "900" },

  /* Range */
  rangeRow: { flexDirection: "row", alignItems: "center", gap: 8, marginTop: 8 },
  rangeLbl: { width: 38, fontSize: 12, color: BLACK, fontWeight: "900" },
  arrowBtn: { width: 30, height: 28, borderRadius: 8, borderWidth: 2, borderColor: BLACK, alignItems: "center", justifyContent: "center", backgroundColor: WHITE },
  rangeVal: { minWidth: 120, textAlign: "center", borderWidth: 2, borderColor: BLACK, borderRadius: 8, paddingVertical: 4, paddingHorizontal: 8, fontSize: 12, fontWeight: "900", color: BLACK, backgroundColor: "#FFFDF2" },

  /* Toggle */
  toggleRow: { flexDirection: "row", gap: 8, marginTop: 8 },
  toggleBtn: { flex: 1, borderWidth: 2, borderColor: BLACK, borderRadius: 12, paddingVertical: 10, alignItems: "center", backgroundColor: WHITE },
  toggleActive: { backgroundColor: "#FFFDF2", borderColor: YELLOW },
  toggleTxt: { fontSize: 12, fontWeight: "900", color: BLACK, textAlign: "center" },
  toggleTxtActive: { color: BLACK },

  /* KPI blocks */
  kpiBlock: { borderWidth: 2, borderColor: BLACK, borderRadius: 12, padding: 10, backgroundColor: WHITE, marginTop: 8 },
  kpiBlockTitle: { fontSize: 12, color: BLACK, fontWeight: "900", marginBottom: 6 },
  bigStat: { fontSize: 16, fontWeight: "900", color: BLACK },
  bigStatInline: { fontSize: 16, fontWeight: "900", color: BLACK },
  kpiHint: { fontSize: 11, color: BLACK, opacity: 0.7 },

  /* Consistency strip */
  consRow: { flexDirection: "row", gap: 6, marginTop: 2 },
  consBox: { width: 12, height: 12, borderRadius: 4, borderWidth: 2, borderColor: BLACK, backgroundColor: WHITE },

  /* H bars (with color swatch) */
  hbarRow: { flexDirection: "row", alignItems: "center", gap: 8, marginTop: 8 },
  hbarLabelWrap: { width: 160, flexDirection: "row", alignItems: "center", gap: 6 },
  legendSwatch: { width: 12, height: 12, borderRadius: 3, borderWidth: 1.5, borderColor: BLACK },
  hbarLabel: { flexShrink: 1, fontSize: 12, color: BLACK },
  hbarTrack: { flex: 1, height: 20, borderRadius: 10, backgroundColor: WHITE, borderWidth: 2, borderColor: BLACK, overflow: "hidden" },
  hbarFill: { height: "100%", borderRightWidth: 2, borderRightColor: BLACK },
  hbarPct: { width: 48, textAlign: "right", fontSize: 12, color: BLACK, fontWeight: "900" },

  /* Proof points grid */
  kpiGrid2: { flexDirection: "row", gap: 8, marginTop: 8, flexWrap: "wrap" },
  kpi: { flexGrow: 1, minWidth: (W - 12 * 2 - 8) / 2 - 8, backgroundColor: WHITE, borderWidth: 2, borderColor: BLACK, borderRadius: 12, padding: 10 },
  kpiLabel: { fontSize: 11, color: BLACK, opacity: 0.8 },
  kpiValue: { fontSize: 20, fontWeight: "900", color: BLACK, marginTop: 2 },

  /* Star row (used by StarsInline) */
  starRow: { flexDirection: "row", alignItems: "center" },
  starVal: { fontSize: 16, fontWeight: "900", color: BLACK },

  /* Simple star distribution list */
  kidRow: { fontSize: 14, fontWeight: "900", color: BLACK, marginTop: 4 },

  sectionHint: { fontSize: 11, color: BLACK, opacity: 0.75 },

  /* ===== Pie chart styles (no libs) ===== */
  pieBox: { justifyContent: "center", alignItems: "center" },
  pieTrack: { position: "absolute", backgroundColor: "#F2F2F2" },
  sliceWrap: { position: "absolute", top: 0, left: 0 },
  halfWrap: { position: "absolute", overflow: "hidden" },
  sliceArc: { position: "absolute", backgroundColor: "transparent" },

  /* Legend grid for pie labels */
  legendGrid: { flexDirection: "row", flexWrap: "wrap", gap: 10, marginTop: 10 },
  legendItem: { flexDirection: "row", alignItems: "center", gap: 6, borderWidth: 2, borderColor: BLACK, borderRadius: 12, paddingVertical: 4, paddingHorizontal: 8, backgroundColor: WHITE },
  legendTxt: { fontSize: 12, color: BLACK, fontWeight: "900", maxWidth: 180 },

  /* Gauge rings (Podium) */
  kpiGrid3: {
    flexDirection: "row",
    justifyContent: "space-around",
    marginTop: 8,
    marginBottom: 4,
  },
  gaugeBox: { alignItems: "center", width: (W - 12 * 2 - 24) / 3 },
  gaugeCircle: {
    width: 92,
    height: 92,
    borderRadius: 46,
    borderWidth: 8,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: WHITE,
  },
  gaugeVal: { fontSize: 18, fontWeight: "900", color: BLACK },
  gaugeLabel: { fontSize: 12, fontWeight: "900", color: BLACK, marginTop: 6 },
});
