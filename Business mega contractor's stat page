// HelpStats.js (Mega Contract Stat Page)
import React, { useMemo, useState } from "react";
import {
  SafeAreaView,
  StatusBar,
  View,
  Text,
  ScrollView,
  StyleSheet,
  Platform,
  TouchableOpacity,
  Dimensions,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";

/* ===== Brand ===== */
const BLACK = "#000";
const WHITE = "#FFF";
const YELLOW = "#FFD54A";
const TOP_BAR_HEIGHT = 88;
const TOP_ACCENT = 3;

/* ===== PRNG + Mock data ===== */
function prng(n) { const x = Math.sin(n) * 10000; return x - Math.floor(x); }

function buildDaily(seed = 1, days = 90) {
  const arr = [];
  const now = new Date();
  for (let i = days - 1; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(now.getDate() - i);
    const k = Number(`${d.getFullYear()}${d.getMonth()+1}${d.getDate()}`) * seed;
    const helps = Math.max(0, Math.round(prng(k) * 4 + (d.getDay() % 2))); // attempts
    const base = 3.6 + prng(k + 7) * 1.2;
    const rating = helps ? Math.min(5, base + Math.min(0.5, helps * 0.06)) : 0;

    const winBias = Math.max(0, (rating - 3.5) / 1.5);
    const winRate = 0.25 + 0.5 * winBias * (0.8 + 0.4 * prng(k + 13));
    const wins = Math.min(helps, Math.round(helps * winRate));

    arr.push({
      date: d,
      label: `${d.getDate()}/${d.getMonth()+1}`,
      helps,
      rating: Number(rating.toFixed(2)),
      wins,
      attempts: helps,
    });
  }
  return arr;
}

function buildActiveMap(ratio = 0.75) {
  const len = 14, activeCount = Math.round(len * ratio);
  const arr = Array(len).fill(false);
  for (let i = 0; i < activeCount; i++) arr[i] = true;
  for (let i = 0; i < len; i++) {
    const j = Math.floor(prng((i + 1) * 999) * len);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

const NICHE_KEYS = ["All", "Mechanical", "Software", "Marketing", "Design"];
const DATA = {
  All: {
    totalReviews: 86, avgRating: 4.7, wins: 18, attempts: 50, consistency: 0.78,
    posTags: { Creative: 72, Clear: 65, Practical: 59, Fast: 61, Helpful: 53, Analytical: 48 },
    improve: { "More Detail": 39, "Simpler Language": 24, "Real Example": 18, "Step-by-Step": 15, "Practical Solution": 12, "Clear Format": 10, "Accurate Information": 9 },
    negFlags: { Unclear: 12, "Overly Brief": 9, Impractical: 7 },
    categories: { Tech: 52, Design: 28, Marketing: 20 },
    repeatSelectors: 6,
    daily: buildDaily(1),
    activeMap: buildActiveMap(0.78),
  },
  Mechanical: {
    totalReviews: 31, avgRating: 4.6, wins: 9, attempts: 31, consistency: 0.74,
    posTags: { Practical: 22, Analytical: 19, Clear: 16, Helpful: 14, Creative: 11, Fast: 10 },
    improve: { "More Detail": 14, "Real Example": 9, "Step-by-Step": 8, "Accurate Information": 6, "Practical Solution": 5, "Clear Format": 4, "Simpler Language": 3 },
    negFlags: { Unclear: 5, "Overly Brief": 4, Impractical: 3 },
    categories: { Mechanical: 70, Manufacturing: 20, Maintenance: 10 },
    repeatSelectors: 3,
    daily: buildDaily(2),
    activeMap: buildActiveMap(0.74),
  },
  Software: {
    totalReviews: 28, avgRating: 4.8, wins: 10, attempts: 29, consistency: 0.81,
    posTags: { Analytical: 20, Clear: 18, Practical: 15, Fast: 15, Helpful: 12, Creative: 10 },
    improve: { "More Detail": 9, "Clear Format": 7, "Step-by-Step": 7, "Accurate Information": 5, "Real Example": 4, "Practical Solution": 4, "Simpler Language": 3 },
    negFlags: { Unclear: 3, "Overly Brief": 3, Impractical: 2 },
    categories: { Backend: 40, Frontend: 35, DevOps: 25 },
    repeatSelectors: 2,
    daily: buildDaily(3),
    activeMap: buildActiveMap(0.81),
  },
  Marketing: {
    totalReviews: 17, avgRating: 4.5, wins: 5, attempts: 19, consistency: 0.70,
    posTags: { Creative: 16, Clear: 12, Practical: 10, Helpful: 9, Analytical: 8, Fast: 7 },
    improve: { "More Detail": 6, "Real Example": 5, "Simpler Language": 4, "Practical Solution": 4, "Clear Format": 3, "Step-by-Step": 2, "Accurate Information": 2 },
    negFlags: { Unclear: 2, "Overly Brief": 2, Impractical: 1 },
    categories: { Content: 45, Growth: 35, Brand: 20 },
    repeatSelectors: 1,
    daily: buildDaily(4),
    activeMap: buildActiveMap(0.7),
  },
  Design: {
    totalReviews: 10, avgRating: 4.6, wins: 4, attempts: 13, consistency: 0.73,
    posTags: { Creative: 12, Clear: 8, Practical: 7, Helpful: 6, Fast: 5, Analytical: 4 },
    improve: { "More Detail": 4, "Clear Format": 3, "Real Example": 2, "Step-by-Step": 2, "Practical Solution": 2, "Simpler Language": 2, "Accurate Information": 1 },
    negFlags: { Unclear: 1, "Overly Brief": 1, Impractical: 0 },
    categories: { UI: 55, UX: 30, Branding: 15 },
    repeatSelectors: 1,
    daily: buildDaily(5),
    activeMap: buildActiveMap(0.73),
  },
};

/* ===== Utils ===== */
const sumVals = (obj) => Object.values(obj).reduce((a, b) => a + b, 0);
const W = Dimensions.get("window").width;
const pad2 = (n) => (n < 10 ? `0${n}` : `${n}`);
const fmt = (dt) => `${pad2(dt.getDate())}/${pad2(dt.getMonth()+1)}/${dt.getFullYear()}`;

/* === STAR DISTRIBUTION === */
function mergeCounts(acc, add) { for (let s = 1; s <= 5; s++) acc[s] = (acc[s] || 0) + (add[s] || 0); return acc; }
function roundPreserve(total, floats, seedBase = 0) {
  const floors = floats.map(Math.floor);
  let rem = total - floors.reduce((a,b)=>a+b,0);
  const order = floats.map((v,i)=>({i, r:v - floors[i]}))
                      .sort((a,b)=> b.r - a.r || prng(seedBase + a.i) - prng(seedBase + b.i));
  const out = floors.slice();
  for (let j = 0; j < rem; j++) out[order[j].i]++;
  return out;
}
function dayStarCountsRealistic(day, seed = 0) {
  if (day.starCounts) { const safe = {1:0,2:0,3:0,4:0,5:0, ...day.starCounts}; return safe; }
  if (Array.isArray(day.ratings)) {
    const c = {1:0,2:0,3:0,4:0,5:0};
    day.ratings.forEach(v => { if (v>=1 && v<=5) c[v]++; });
    return c;
  }
  const h = Math.max(0, day.helps || 0);
  if (!h) return {1:0,2:0,3:0,4:0,5:0};
  const r = Math.max(1, Math.min(5, day.rating || 3.5));
  const sigma = 1.0 - Math.min(0.6, Math.log10(Math.max(1, h)) * 0.25);
  const weights = [1,2,3,4,5].map((s, i) => {
    const base = Math.exp(-Math.pow(s - r, 2) / (2 * sigma * sigma));
    const jitter = 0.9 + 0.2 * prng(seed + i);
    return base * jitter;
  });
  const sumW = weights.reduce((a,b)=>a+b,0) || 1;
  const probs = weights.map(w => w / sumW);
  const floats = probs.map(p => p * h);
  const [c1,c2,c3,c4,c5] = roundPreserve(h, floats, seed);
  return {1:c1,2:c2,3:c3,4:c4,5:c5};
}
function distForRange(days) {
  return days.reduce((acc, p, idx) => {
    const counts = dayStarCountsRealistic(p, (p.date?.getTime?.() || idx) + idx);
    return mergeCounts(acc, counts);
  }, {1:0,2:0,3:0,4:0,5:0});
}

/* GREEN tags (exact list) */
function strengthsFromInterval(inRange, d) {
  const base = {
    creative: d.posTags.Creative || 40,
    analytical: d.posTags.Analytical || 40,
    practical: d.posTags.Practical || 40,
    detailed: (d.posTags.Clear || 30) + (d.posTags.Fast || 0) * 0.2,
    clear: d.posTags.Clear || 30,
    insightful: (d.posTags.Clear || 25) + (d.posTags.Creative || 0) * 0.3,
    innovative: (d.posTags.Creative || 25) + (d.posTags.Analytical || 0) * 0.2,
    professional: (d.posTags.Clear || 25) + 20,
    "high-impact": (d.posTags.Practical || 0) * 0.55 + (d.posTags.Creative || 0) * 0.45,
    depth: (d.posTags.Clear || 0) * 0.4 + (d.posTags.Practical || 0) * 0.3 + (d.posTags.Analytical || 0) * 0.3,
  };
  const keys = Object.keys(base);
  const totalBase = keys.reduce((a,k)=>a+base[k],0) || 1;
  const counts = Object.fromEntries(keys.map(k=>[k,0]));
  let total = 0;

  inRange.forEach((p, idx) => {
    const h = p.helps || 0; total += h;
    keys.forEach((k, i) => {
      const jitter = 0.9 + 0.2 * prng(h + base[k] + i + idx);
      counts[k] += (h * (base[k] / totalBase)) * jitter;
    });
  });

  if (!total) return Object.fromEntries(keys.map(k=>[k,0]));
  const pct = {};
  keys.forEach(k => { pct[k] = Math.round((counts[k] / total) * 100); });
  return pct;
}

/* RED tags (exact list) */
function improveFromInterval(inRange, d) {
  const base = {
    "undetailed explanation": (d.improve["More Detail"] || 0),
    "overcomplicated": (d.improve["Simpler Language"] || 0) + (d.improve["Clear Format"] || 0),
    "unconcreted illustration": (d.improve["Real Example"] || 0),
    "unclear solution": (d.negFlags.Unclear || 0),
    "not actionable": (d.improve["Practical Solution"] || 0),
    "messy explanation": (d.improve["Clear Format"] || 0) + (d.negFlags["Overly Brief"] || 0),
    "misleading fact": (d.improve["Accurate Information"] || 0),
  };
  const reasons = Object.keys(base);
  const weightSum = reasons.reduce((a,k)=>a+base[k],0) || 1;

  const counts = Object.fromEntries(reasons.map(k=>[k,0]));
  let totalIssues = 0;

  inRange.forEach((p, idx) => {
    const dist = dayStarCountsRealistic(p, idx);
    const notFive = (p.helps || 0) - (dist[5] || 0);
    totalIssues += notFive;
    reasons.forEach((k, i) => {
      const jitter = 0.9 + 0.2 * prng(notFive + base[k] + i + idx);
      counts[k] += (notFive * (base[k] / weightSum)) * jitter;
    });
  });

  if (!totalIssues) return Object.fromEntries(reasons.map(k=>[k,0]));
  const pct = {};
  reasons.forEach(k => { pct[k] = Math.round((counts[k] / totalIssues) * 100); });
  return pct;
}

/* ===== Reusable UI ===== */
function TitleRow({ title, help }) {
  const [open, setOpen] = useState(false);
  return (
    <View style={{ marginBottom: open ? 8 : 0 }}>
      <View style={styles.titleRow}>
        <Text style={styles.cardTitle}>{title}</Text>
        <TouchableOpacity
          onPress={() => setOpen((v) => !v)}
          activeOpacity={0.85}
          style={styles.infoBtn}
          hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}
        >
          <Text style={styles.infoTxt}>i</Text>
        </TouchableOpacity>
      </View>
      {open && (
        <View style={styles.helpBox}>
          <Text style={styles.helpText}>{help}</Text>
        </View>
      )}
    </View>
  );
}
function Card({ children }) { return <View style={styles.card}>{children}</View>; }
function Chip({ text, active, onPress }) {
  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.9}
      style={[styles.chip, active && { backgroundColor: "#FFFDF2", borderColor: YELLOW }]}
    >
      <Text style={styles.chipTxt}>{text}</Text>
    </TouchableOpacity>
  );
}
function HBar({ label, pct, big = false }) {
  return (
    <View style={styles.hbarRow}>
      <Text style={[styles.hbarLabel, big && { width: 180 }]} numberOfLines={1}>{label}</Text>
      <View style={[styles.hbarTrack, big && { height: 20 }]}>
        <View style={[styles.hbarFill, { width: `${Math.max(4, pct)}%` }]} />
      </View>
      <Text style={styles.hbarPct}>{pct}%</Text>
    </View>
  );
}
function StarMeter({ value = 0 }) {
  const full = Math.floor(value);
  const hasHalf = value - full >= 0.5;
  const stars = Array(5).fill("star-outline").map((_, i) =>
    i < full ? "star" : i === full && hasHalf ? "star-half" : "star-outline"
  );
  return (
    <View style={styles.starRow}>
      {stars.map((name, i) => (
        <Ionicons key={i} name={name} size={16} color={BLACK} />
      ))}
      <Text style={styles.starVal}>{value.toFixed(1)}★</Text>
    </View>
  );
}

/* === Circular percent diagram (no external libs) === */
function CirclePct({ pct = 0, size = 96, thickness = 10, color = "#5AC8FA", track = "#EDEDED", label = "" }) {
  const p = Math.max(0, Math.min(100, Math.round(pct)));
  const angle = (p / 100) * 360;
  const rightAngle = Math.min(angle, 180);
  const leftAngle = angle > 180 ? angle - 180 : 0;

  return (
    <View style={{ alignItems: "center", justifyContent: "center" }}>
      <View style={{ width: size, height: size }}>
        {/* track */}
        <View style={{
          position: "absolute", width: size, height: size, borderRadius: size/2,
          borderWidth: thickness, borderColor: track
        }} />
        {/* right half */}
        <View style={{
          position: "absolute", left: size/2, top: 0, width: size/2, height: size, overflow: "hidden"
        }}>
          <View style={{
            position: "absolute", left: -size/2, top: 0, width: size, height: size,
            borderRadius: size/2, borderWidth: thickness, borderColor: color,
            transform: [{ rotateZ: `${rightAngle}deg` }]
          }} />
        </View>
        {/* left half */}
        <View style={{
          position: "absolute", left: 0, top: 0, width: size/2, height: size, overflow: "hidden"
        }}>
          <View style={{
            position: "absolute", left: 0, top: 0, width: size, height: size,
            borderRadius: size/2, borderWidth: thickness, borderColor: color,
            transform: [{ rotateZ: `${leftAngle}deg` }]
          }} />
        </View>

        {/* center text */}
        <View style={[StyleSheet.absoluteFill, { alignItems: "center", justifyContent: "center" }]}>
          <Text style={{ fontSize: 18, fontWeight: "900", color: BLACK }}>{p}%</Text>
        </View>
      </View>
      {!!label && <Text style={{ marginTop: 8, fontSize: 12, fontWeight: "900", color: BLACK, textAlign: "center" }}>{label}</Text>}
    </View>
  );
}

/* ===== Main Page ===== */
export default function App() {
  const [niche, setNiche] = useState("All");
  const d = DATA[niche];
  const all = d.daily;

  // Date interval
  const [startIdx, setStartIdx] = useState(Math.max(0, all.length - 14));
  const [endIdx, setEndIdx] = useState(all.length - 1);
  const inRange = useMemo(() => all.slice(startIdx, endIdx + 1), [all, startIdx, endIdx]);

  const [ratingDistScope, setRatingDistScope] = useState("interval"); // 'interval' | 'all'
  const [greenScope, setGreenScope] = useState("interval");
  const [redScope, setRedScope] = useState("interval");
  const [proofScope, setProofScope] = useState("interval");

  // Interval totals
  const interval = useMemo(() => {
    const helps = inRange.reduce((a,b)=>a+b.helps,0);
    const gainedStars = inRange.reduce((a,b)=>a + Math.round(b.rating * b.helps),0);
    const possibleStars = inRange.reduce((a,b)=>a + b.helps*5,0);
    const wins = inRange.reduce((a,b)=>a + b.wins,0);
    const attempts = inRange.reduce((a,b)=>a + b.attempts,0);
    const dist = distForRange(inRange);
    const avgPerHelp = helps ? (gainedStars / helps) : 0;
    return { helps, gainedStars, possibleStars, wins, attempts, dist, avgPerHelp };
  }, [inRange]);

  // All-time totals
  const allTime = useMemo(() => {
    const helps = all.reduce((a,b)=>a+b.helps,0);
    const gainedStars = all.reduce((a,b)=>a + Math.round(b.rating * b.helps),0);
    const possibleStars = all.reduce((a,b)=>a + b.helps*5,0);
    const wins = all.reduce((a,b)=>a + b.wins,0);
    const attempts = all.reduce((a,b)=>a + b.attempts,0);
    const dist = distForRange(all);
    const avgPerHelp = helps ? (gainedStars / helps) : 0;
    return { helps, gainedStars, possibleStars, wins, attempts, dist, avgPerHelp };
  }, [all]);

  const greenInterval = useMemo(() => strengthsFromInterval(inRange, d), [inRange, d]);
  const greenAll = useMemo(() => strengthsFromInterval(all, d), [all, d]);
  const redInterval = useMemo(() => improveFromInterval(inRange, d), [inRange, d]);
  const redAll = useMemo(() => improveFromInterval(all, d), [all, d]);

  const scopePack = proofScope === "interval" ? interval : allTime;
  const finalPct = (() => {
    const a = Math.max(1, scopePack.attempts);
    return Math.round((scopePack.wins / a) * 100);
  })();
  const semiPct = (() => {
    const dists = scopePack.dist;
    const total = (dists[1]||0)+(dists[2]||0)+(dists[3]||0)+(dists[4]||0)+(dists[5]||0) || 1;
    return Math.round(((dists[4]||0 + dists[5]||0) / total) * 100);
  })();

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor={BLACK} />

      {/* Top bar with updated title */}
      <View style={styles.topBar}>
        <TouchableOpacity style={styles.backBtn} activeOpacity={0.7}>
          <Ionicons name="chevron-back" size={24} color={WHITE} />
        </TouchableOpacity>

        <Text style={styles.topTitle}>business mega contractee's stat page</Text>

        <View style={{ width: 40, height: 36 }} />
      </View>

      <View style={styles.topAccent} />

      <ScrollView contentContainerStyle={{ padding: 12, paddingBottom: 24 }}>
        {/* Niche */}
        <Card>
          <TitleRow title="Niche" help="Pick a field. All numbers below use only COMPETITION data for that field (demo uses HELP stand-ins)." />
          <View style={styles.nicheRow}>
            {NICHE_KEYS.map((k) => (
              <Chip key={k} text={k} active={niche === k} onPress={() => setNiche(k)} />
            ))}
          </View>
        </Card>

        {/* RATING & DATA */}
        <Card>
          <TitleRow
            title="Rating and Data"
            help="Choose a date window. Use the toggle to switch between this interval and all-time."
          />

          {/* Date range pickers */}
          <View style={styles.rangeRow}>
            <Text style={styles.rangeLbl}>From</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => setStartIdx((s)=>Math.max(0, s-1))}>
              <Ionicons name="chevron-back" size={16} color={BLACK} />
            </TouchableOpacity>
            <Text style={styles.rangeVal}>{fmt(all[startIdx].date)}</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => setStartIdx((s)=>Math.min(endIdx, s+1))}>
              <Ionicons name="chevron-forward" size={16} color={BLACK} />
            </TouchableOpacity>
          </View>
          <View style={styles.rangeRow}>
            <Text style={styles.rangeLbl}>To</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => setEndIdx((e)=>Math.max(startIdx, e-1))}>
              <Ionicons name="chevron-back" size={16} color={BLACK} />
            </TouchableOpacity>
            <Text style={styles.rangeVal}>{fmt(all[endIdx].date)}</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => setEndIdx((e)=>Math.min(all.length-1, e+1))}>
              <Ionicons name="chevron-forward" size={16} color={BLACK} />
            </TouchableOpacity>
          </View>

          {/* Shared toggle for Average Rating + Star Distribution */}
          <View style={styles.toggleRow}>
            <TouchableOpacity
              style={[styles.toggleBtn, ratingDistScope === "interval" && styles.toggleActive]}
              onPress={() => setRatingDistScope("interval")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, ratingDistScope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.toggleBtn, ratingDistScope === "all" && styles.toggleActive]}
              onPress={() => setRatingDistScope("all")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, ratingDistScope === "all" && styles.toggleTxtActive]}>All-Time</Text>
            </TouchableOpacity>
          </View>

          {/* Average Rating */}
          <View style={styles.kpiBlock}>
            <Text style={styles.kpiBlockTitle}>Average Rating</Text>
            <StarMeter
              value={
                ratingDistScope === "interval"
                  ? (interval.helps ? interval.gainedStars / interval.helps : 0)
                  : (allTime.helps ? allTime.gainedStars / allTime.helps : 0)
              }
            />
            <Text style={[styles.kpiHint, { marginTop: 6 }]}>
              Stars earned:{" "}
              <Text style={styles.bigStatInline}>
                {ratingDistScope === "interval" ? interval.gainedStars : allTime.gainedStars}
              </Text>{" "}
              / {ratingDistScope === "interval" ? interval.possibleStars : allTime.possibleStars}
            </Text>
            <Text style={styles.kpiHint}>
              Competition overall: <Text style={styles.bigStatInline}>{d.totalReviews}</Text>
            </Text>
          </View>

          {/* Star Distribution — SAME toggle */}
          <View style={[styles.kpiBlock, { marginTop: 8 }]}>
            <Text style={styles.kpiBlockTitle}>Star Distribution</Text>
            {["5","4","3","2","1"].map(s => (
              <Text key={s} style={styles.kidRow}>
                {"⭐".repeat(Number(s)).padEnd(5," ")} = {(ratingDistScope === "interval" ? interval.dist : allTime.dist)[s]} entries
              </Text>
            ))}
            <Text style={styles.kpiHint}>
              Counts use real ratings when available; otherwise modeled per-day from average rating and attempts.
            </Text>
          </View>
        </Card>

        {/* Green Tags */}
        <Card>
          <TitleRow
            title="Green Tags"
            help="What your answers most frequently demonstrated."
          />
          <View style={styles.toggleRow}>
            <TouchableOpacity
              style={[styles.toggleBtn, greenScope === "interval" && styles.toggleActive]}
              onPress={() => setGreenScope("interval")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, greenScope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.toggleBtn, greenScope === "all" && styles.toggleActive]}
              onPress={() => setGreenScope("all")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, greenScope === "all" && styles.toggleTxtActive]}>All-Time</Text>
            </TouchableOpacity>
          </View>
          <View style={{ marginTop: 6 }}>
            {[
              ["💡 creative", (greenScope === "interval" ? greenInterval : greenAll)["creative"]],
              ["🧠 analytical", (greenScope === "interval" ? greenInterval : greenAll)["analytical"]],
              ["🔧 practical", (greenScope === "interval" ? greenInterval : greenAll)["practical"]],
              ["📝 detailed", (greenScope === "interval" ? greenInterval : greenAll)["detailed"]],
              ["🧼 clear", (greenScope === "interval" ? greenInterval : greenAll)["clear"]],
              ["👀 insightful", (greenScope === "interval" ? greenInterval : greenAll)["insightful"]],
              ["🚀 innovative", (greenScope === "interval" ? greenInterval : greenAll)["innovative"]],
              ["🎓 professional", (greenScope === "interval" ? greenInterval : greenAll)["professional"]],
              ["📈 high-impact", (greenScope === "interval" ? greenInterval : greenAll)["high-impact"]],
              ["🏊 depth", (greenScope === "interval" ? greenInterval : greenAll)["depth"]],
            ].map(([label, pct]) => (
              <HBar key={label} label={label} pct={pct || 0} big />
            ))}
          </View>
        </Card>

        {/* Red Tags */}
        <Card>
          <TitleRow
            title="Red Tags"
            help="Main reasons an answer didn’t score 5★."
          />
          <View style={styles.toggleRow}>
            <TouchableOpacity
              style={[styles.toggleBtn, redScope === "interval" && styles.toggleActive]}
              onPress={() => setRedScope("interval")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, redScope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.toggleBtn, redScope === "all" && styles.toggleActive]}
              onPress={() => setRedScope("all")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, redScope === "all" && styles.toggleTxtActive]}>All-Time</Text>
            </TouchableOpacity>
          </View>
          <View style={{ marginTop: 6 }}>
            {[
              ["🪫 undetailed explanation", (redScope === "interval" ? redInterval : redAll)["undetailed explanation"]],
              ["🧩 overcomplicated", (redScope === "interval" ? redInterval : redAll)["overcomplicated"]],
              ["📦 unconcreted illustration", (redScope === "interval" ? redInterval : redAll)["unconcreted illustration"]],
              ["❓ unclear solution", (redScope === "interval" ? redInterval : redAll)["unclear solution"]],
              ["🚫 not actionable", (redScope === "interval" ? redInterval : redAll)["not actionable"]],
              ["🌀 messy explanation", (redScope === "interval" ? redInterval : redAll)["messy explanation"]],
              ["⚠️ misleading fact", (redScope === "interval" ? redInterval : redAll)["misleading fact"]],
            ].map(([label, pct]) => (
              <HBar key={label} label={label} pct={pct || 0} big />
            ))}
          </View>
        </Card>

        {/* Proof points — donuts only */}
        <Card>
          <TitleRow
            title="Proof Points"
            help="Qualification rates for competitions. Final = picked as winner. Semi-final = advanced to later rounds (approx. 4★–5★)."
          />
          <View style={styles.toggleRow}>
            <TouchableOpacity
              style={[styles.toggleBtn, proofScope === "interval" && styles.toggleActive]}
              onPress={() => setProofScope("interval")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, proofScope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.toggleBtn, proofScope === "all" && styles.toggleActive]}
              onPress={() => setProofScope("all")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, proofScope === "all" && styles.toggleTxtActive]}>All-Time</Text>
            </TouchableOpacity>
          </View>

          <View style={{ flexDirection: "row", justifyContent: "space-around", marginTop: 8 }}>
            <CirclePct pct={finalPct} size={100} thickness={10} color={YELLOW} label="Final qualification" />
            <CirclePct pct={semiPct} size={100} thickness={10} color={"#5AC8FA"} label="Semi-final qualification" />
          </View>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
}

/* ===== Styles ===== */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: WHITE },

  /* Top bar */
  topBar: {
    backgroundColor: BLACK,
    height: TOP_BAR_HEIGHT,
    paddingTop: Platform.OS === "android" ? (StatusBar.currentHeight || 0) : 12,
    paddingHorizontal: 12,
    paddingBottom: 12,
    flexDirection: "row",
    alignItems: "flex-end",
    justifyContent: "space-between",
  },
  topAccent: { height: TOP_ACCENT, backgroundColor: YELLOW },
  backBtn: { width: 40, height: 36, justifyContent: "center" },
  topTitle: { color: WHITE, fontWeight: "900", fontSize: 16 },

  /* Cards */
  card: { backgroundColor: WHITE, borderWidth: 2, borderColor: BLACK, borderRadius: 14, padding: 12, marginBottom: 12 },
  titleRow: { flexDirection: "row", justifyContent: "space-between", alignItems: "center" },
  cardTitle: { fontSize: 14, fontWeight: "900", color: BLACK },
  infoBtn: {
    width: 22, height: 22, borderRadius: 11,
    borderWidth: 2, borderColor: BLACK,
    alignItems: "center", justifyContent: "center", backgroundColor: WHITE,
  },
  infoTxt: { fontWeight: "900", color: BLACK, fontSize: 12 },
  helpBox: { marginTop: 8, borderWidth: 2, borderColor: BLACK, borderRadius: 10, padding: 8, backgroundColor: "#FFFDF2" },
  helpText: { color: BLACK, fontSize: 12 },

  /* Niche row */
  nicheRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  chip: { paddingVertical: 6, paddingHorizontal: 10, borderRadius: 16, borderWidth: 2, borderColor: BLACK, backgroundColor: WHITE },
  chipTxt: { color: BLACK, fontSize: 12, fontWeight: "900" },

  /* Range */
  rangeRow: { flexDirection: "row", alignItems: "center", gap: 8, marginTop: 8 },
  rangeLbl: { width: 38, fontSize: 12, color: BLACK, fontWeight: "900" },
  arrowBtn: { width: 30, height: 28, borderRadius: 8, borderWidth: 2, borderColor: BLACK, alignItems: "center", justifyContent: "center", backgroundColor: WHITE },
  rangeVal: { minWidth: 120, textAlign: "center", borderWidth: 2, borderColor: BLACK, borderRadius: 8, paddingVertical: 4, paddingHorizontal: 8, fontSize: 12, fontWeight: "900", color: BLACK, backgroundColor: "#FFFDF2" },

  /* Toggle */
  toggleRow: { flexDirection: "row", gap: 8, marginTop: 8 },
  toggleBtn: { flex: 1, borderWidth: 2, borderColor: BLACK, borderRadius: 12, paddingVertical: 10, alignItems: "center", backgroundColor: WHITE },
  toggleActive: { backgroundColor: "#FFFDF2", borderColor: YELLOW },
  toggleTxt: { fontSize: 12, fontWeight: "900", color: BLACK, textAlign: "center" },
  toggleTxtActive: { color: BLACK },

  /* KPI blocks */
  kpiBlock: { borderWidth: 2, borderColor: BLACK, borderRadius: 12, padding: 10, backgroundColor: WHITE, marginTop: 8 },
  kpiBlockTitle: { fontSize: 12, color: BLACK, fontWeight: "900", marginBottom: 6 },
  bigStatInline: { fontSize: 16, fontWeight: "900", color: BLACK },

  /* Star meter */
  starRow: { flexDirection: "row", alignItems: "center", gap: 4 },
  starVal: { marginLeft: 6, fontSize: 16, fontWeight: "900", color: BLACK },

  /* Simple star distribution list */
  kidRow: { fontSize: 14, fontWeight: "900", color: BLACK, marginTop: 4 },

  /* H bars */
  hbarRow: { flexDirection: "row", alignItems: "center", gap: 8, marginTop: 8 },
  hbarLabel: { width: 140, fontSize: 12, color: BLACK },
  hbarTrack: { flex: 1, height: 20, borderRadius: 10, backgroundColor: WHITE, borderWidth: 2, borderColor: BLACK, overflow: "hidden" },
  hbarFill: { height: "100%", backgroundColor: YELLOW, borderRightWidth: 2, borderRightColor: BLACK },
  hbarPct: { width: 48, textAlign: "right", fontSize: 12, color: BLACK, fontWeight: "900" },
});
