// App.js — MiniContractStats (Snack/Expo Go ready)
// Updates for your request:
//  • Removed Green tags: reliability, prudent
//  • Strong, non-repeating, high-contrast colors (Category10-style) per tag
//  • Green & Red each have their own pie and legend with counts like "Speed (30 tags)"

import React, { useMemo, useState } from "react";
import {
  SafeAreaView,
  StatusBar,
  View,
  Text,
  ScrollView,
  StyleSheet,
  Platform,
  TouchableOpacity,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import Svg, { G, Path } from "react-native-svg"; // Snack will ask to add dependency

/* ===== Brand ===== */
const BLACK = "#000";
const WHITE = "#FFF";
const YELLOW = "#FFD54A";
const TOP_BAR_HEIGHT = 88;
const TOP_ACCENT = 3;

/* ===== PRNG + Mock MINI-CONTRACT data ===== */
function prng(n) { const x = Math.sin(n) * 10000; return x - Math.floor(x); }

function buildDailyMini(seed = 2, days = 90) {
  const arr = [];
  const now = new Date();
  for (let i = days - 1; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(now.getDate() - i);
    const k = Number(`${d.getFullYear()}${d.getMonth()+1}${d.getDate()}`) * seed;

    // number of mini contracts finished per day
    const jobs = Math.max(0, Math.round(prng(k) * 3 + (d.getDay() % 2)));

    // Base ratings for both toggles
    const satBase   = 3.9 + prng(k + 11) * 1.0; // Satisfaction (result)
    const csBase    = 4.0 + prng(k + 17) * 0.9; // Customer Service (experience)
    const wBias     = (d.getDay() === 0 || d.getDay() === 6) ? -0.1 : 0.05;

    const satisfactionRating    = jobs ? Math.max(1, Math.min(5, satBase + wBias)) : 0;
    const customerServiceRating = jobs ? Math.max(1, Math.min(5, csBase  - 0.05 + wBias)) : 0;

    const abandonProb = 0.05 + 0.05 * prng(k + 23); // 5–10%
    const abandoned   = Math.round(jobs * abandonProb);

    const referralProb = 0.15 + 0.10 * prng(k + 29); // 15–25%
    const referrals    = Math.round(jobs * referralProb);

    const rehireProb = 0.20 + 0.10 * prng(k + 31); // 20–30%
    const rehire     = Math.round(jobs * rehireProb);

    arr.push({
      date: d,
      label: `${d.getDate()}/${d.getMonth()+1}`,
      jobs,
      satisfactionRating: Number(satisfactionRating.toFixed(2)),
      customerServiceRating: Number(customerServiceRating.toFixed(2)),
      abandoned,
      referrals,
      rehire,
    });
  }
  return arr;
}

const NICHE_KEYS = ["All", "Mechanical", "Software", "Marketing", "Design", "Events"];

// Mock dataset per niche
const DATA = {
  All:        { totalReviews: 142, avgSatisfaction: 4.6, avgService: 4.7, daily: buildDailyMini(2) },
  Mechanical: { totalReviews: 58,  avgSatisfaction: 4.5, avgService: 4.6, daily: buildDailyMini(3) },
  Software:   { totalReviews: 45,  avgSatisfaction: 4.7, avgService: 4.6, daily: buildDailyMini(4) },
  Marketing:  { totalReviews: 29,  avgSatisfaction: 4.4, avgService: 4.6, daily: buildDailyMini(5) },
  Design:     { totalReviews: 22,  avgSatisfaction: 4.5, avgService: 4.6, daily: buildDailyMini(6) },
  Events:     { totalReviews: 31,  avgSatisfaction: 4.5, avgService: 4.7, daily: buildDailyMini(7) },
};

/* ===== Utils ===== */
const pad2 = (n) => (n < 10 ? `${n}`.padStart(2, "0") : `${n}`);
const fmt = (dt) => `${pad2(dt.getDate())}/${pad2(dt.getMonth()+1)}/${dt.getFullYear()}`;

/* === STAR DISTRIBUTION (interval-aware) === */
function roundPreserve(total, floats, seedBase = 0) {
  const floors = floats.map(Math.floor);
  let rem = total - floors.reduce((a,b)=>a+b,0);
  const order = floats.map((v,i)=>({i, r:v - floors[i]}))
                      .sort((a,b)=> b.r - a.r || prng(seedBase + a.i) - prng(seedBase + b.i));
  const out = floors.slice();
  for (let j = 0; j < rem; j++) out[order[j].i]++;
  return out;
}
function dayStarCountsFromAvg(avg, count, seed = 0) {
  const h = Math.max(0, count || 0);
  if (!h) return {1:0,2:0,3:0,4:0,5:0};
  const r = Math.max(1, Math.min(5, avg || 3.5));
  const sigma = 1.0 - Math.min(0.6, Math.log10(Math.max(1, h)) * 0.25);
  const weights = [1,2,3,4,5].map((s, i) => {
    const base = Math.exp(-Math.pow(s - r, 2) / (2 * sigma * sigma));
    const jitter = 0.9 + 0.2 * prng(seed + i);
    return base * jitter;
  });
  const sumW = weights.reduce((a,b)=>a+b,0) || 1;
  const probs = weights.map(w => w / sumW);
  const floats = probs.map(p => p * h);
  const [c1,c2,c3,c4,c5] = roundPreserve(h, floats, seed);
  return {1:c1,2:c2,3:c3,4:c4,5:c5};
}
function intervalStarDistribution(inRange, mode = "satisfaction") {
  return inRange.reduce((acc, p, idx) => {
    const avg = mode === "satisfaction" ? p.satisfactionRating : p.customerServiceRating;
    const counts = dayStarCountsFromAvg(avg, p.jobs, (p.date?.getTime?.() || idx) + idx);
    acc[1] = (acc[1] || 0) + counts[1];
    acc[2] = (acc[2] || 0) + counts[2];
    acc[3] = (acc[3] || 0) + counts[3];
    acc[4] = (acc[4] || 0) + counts[4];
    acc[5] = (acc[5] || 0) + counts[5];
    return acc;
  }, {1:0,2:0,3:0,4:0,5:0});
}

/* ===== Tag Lists ===== */
/* Removed from green: reliability, prudent */
const GREEN_TAGS = [
  "sharp","punctuality","speed","experience","flexibility",
  "trust","proactive","strategic","polite","problem-solving"
];
const RED_TAGS = [
  "lateness","unprofessional","conflict","unreliable","dishonesty","wasteful",
  "unexperienced","disorganized","rigid","slow"
];

/* ===== DISTINCT color assignment (high-contrast categorical) ===== */
const CATEGORY10 = [
  "#1f77b4", // blue
  "#ff7f0e", // orange
  "#2ca02c", // green
  "#d62728", // red
  "#9467bd", // purple
  "#8c564b", // brown
  "#e377c2", // pink
  "#7f7f7f", // gray
  "#bcbd22", // chartreuse
  "#17becf", // cyan
];
// Fallback hue if ever needed (not used here since we have ≤10 per group)
function hslToHex(h, s, l) {
  s /= 100; l /= 100;
  const k = n => (n + h / 30) % 12;
  const a = s * Math.min(l, 1 - l);
  const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
  const toHex = x => Math.round(255 * x).toString(16).padStart(2, "0");
  return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
}
function colorMapForTags(list, offset = 0) {
  const colors = [];
  for (let i = 0; i < list.length; i++) {
    if (i < CATEGORY10.length) {
      colors.push(CATEGORY10[(i + offset) % CATEGORY10.length]);
    } else {
      const hue = (i * 137.508) % 360; // very separated backup
      colors.push(hslToHex(hue, 75, 50));
    }
  }
  const map = {};
  list.forEach((t, i) => { map[t] = colors[i]; });
  return map;
}

/* ===== Use COUNTS (not %) for tags, scaled to nice integers ===== */
function tagCountsFromWindow(days, list, seedSalt = 0) {
  const totals = Object.fromEntries(list.map(t => [t, 0]));
  days.forEach((p) => {
    const jobs = p.jobs || 0;
    list.forEach((t, i) => {
      const s = 0.5 + 0.5 * prng((p.date?.getTime?.() || 0) + seedSalt * 1000 + i * 77);
      totals[t] += jobs * s; // more jobs that day -> stronger tag signal
    });
  });
  const maxVal = Math.max(1, ...Object.values(totals));
  const scale = 40 / maxVal; // biggest ≈ 40 tags
  return list
    .map((t) => ({ tag: t, count: Math.max(0, Math.round(totals[t] * scale)) }))
    .sort((a, b) => b.count - a.count);
}

/* ===== Reusable UI ===== */
function TitleRow({ title, help }) {
  const [open, setOpen] = useState(false);
  return (
    <View style={{ marginBottom: open ? 8 : 0 }}>
      <View style={styles.titleRow}>
        <Text style={styles.cardTitle}>{title}</Text>
        <TouchableOpacity
          onPress={() => setOpen((v) => !v)}
          activeOpacity={0.85}
          style={styles.infoBtn}
          hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}
        >
          <Text style={styles.infoTxt}>i</Text>
        </TouchableOpacity>
      </View>
      {open && (
        <View style={styles.helpBox}>
          <Text style={styles.helpText}>{help}</Text>
        </View>
      )}
    </View>
  );
}
function Card({ children }) { return <View style={styles.card}>{children}</View>; }
function Chip({ text, active, onPress }) {
  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.9}
      style={[styles.chip, active && { backgroundColor: "#FFFDF2", borderColor: YELLOW }]}
    >
      <Text style={styles.chipTxt}>{text}</Text>
    </TouchableOpacity>
  );
}
function StarMeter({ value = 0 }) {
  const full = Math.floor(value);
  const hasHalf = value - full >= 0.5;
  const stars = Array(5).fill("star-outline").map((_, i) =>
    i < full ? "star" : i === full && hasHalf ? "star-half" : "star-outline"
  );
  return (
    <View style={styles.starRow}>
      {stars.map((name, i) => (
        <Ionicons key={i} name={name} size={16} color={BLACK} />
      ))}
      <Text style={styles.starVal}>{value.toFixed(1)}★</Text>
    </View>
  );
}

/* ===== 360° Circular Gauge (donut) ===== */
function GaugeRing({ label, pct = 0, size = 84, thickness = 10 }) {
  const p = Math.max(0, Math.min(100, Number.isFinite(pct) ? pct : 0));
  const angle = (p / 100) * 360;
  const rightAngle = Math.min(angle, 180);
  const leftAngle  = Math.max(angle - 180, 0);

  return (
    <View style={[styles.gaugeWrap, { width: size + 24 }]}>
      <View style={[styles.gaugeBox, { width: size, height: size }]}>
        {/* Track */}
        <View style={[styles.gaugeTrack, { width: size, height: size, borderRadius: size/2, borderWidth: thickness }]} />
        {/* Right half */}
        <View style={[styles.halfWrap, { width: size/2, height: size, right: size/2 }]}>
          <View style={[styles.arc, { width: size, height: size, borderRadius: size/2, borderWidth: thickness, transform: [{ rotateZ: `${rightAngle}deg` }] }]} />
        </View>
        {/* Left half */}
        <View style={[styles.halfWrap, { width: size/2, height: size, left: size/2 }]}>
          <View style={[styles.arc, { width: size, height: size, borderRadius: size/2, borderWidth: thickness, transform: [{ rotateZ: `${leftAngle}deg` }], opacity: angle > 180 ? 1 : 0 }]} />
        </View>
        {/* Inner hole + % */}
        <View style={[styles.gaugeHole, { width: size - thickness*2, height: size - thickness*2, borderRadius: (size - thickness*2)/2 }]}>
          <Text style={styles.gaugePct}>{Math.round(p)}%</Text>
        </View>
      </View>
      <Text style={styles.gaugeLabel} numberOfLines={2}>{label}</Text>
    </View>
  );
}

/* ===== Tiny pie (SVG) ===== */
function polarToCartesian(cx, cy, r, angle) {
  const a = ((angle - 90) * Math.PI) / 180.0;
  return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
}
function arcPath(cx, cy, r, startAngle, endAngle) {
  const start = polarToCartesian(cx, cy, r, endAngle);
  const end = polarToCartesian(cx, cy, r, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
  return `M ${cx} ${cy} L ${start.x} ${start.y} A ${r} ${r} 0 ${largeArcFlag} 0 ${end.x} ${end.y} Z`;
}
function PieChart({ data = [], size = 160, stroke = 2 }) {
  const total = Math.max(1, data.reduce((s, d) => s + (d.count || 0), 0));
  const cx = size / 2;
  const cy = size / 2;
  const r = size / 2 - stroke;
  let angle = 0;
  const paths = data.map((d, i) => {
    const slice = (d.count / total) * 360;
    const start = angle;
    const end = angle + slice;
    angle = end;
    const dPath = arcPath(cx, cy, r, start, end);
    return <Path key={i} d={dPath} stroke={BLACK} strokeWidth={1.5} fill={d.color} />;
  });
  return (
    <Svg width={size} height={size}>
      <G>{paths}</G>
    </Svg>
  );
}

const cap = (s) => s.charAt(0).toUpperCase() + s.slice(1);

/* ===== Main Page ===== */
export default function App() {
  const [niche, setNiche] = useState("All");
  const d = DATA[niche];
  const all = d.daily;

  // Date interval
  const [startIdx, setStartIdx] = useState(Math.max(0, all.length - 14));
  const [endIdx, setEndIdx] = useState(all.length - 1);
  const inRange = useMemo(() => all.slice(startIdx, endIdx + 1), [all, startIdx, endIdx]);
  const shiftStart = (dir) => setStartIdx((s) => Math.min(endIdx, Math.max(0, s + dir)));
  const shiftEnd   = (dir) => setEndIdx((e) => Math.max(startIdx, Math.min(all.length - 1, e + dir)));

  // Toggles
  const [ratingMode, setRatingMode] = useState("satisfaction"); // "satisfaction" | "service"
  const [ratesScope, setRatesScope] = useState("interval");     // "interval" | "all"
  const [tagsScope, setTagsScope] = useState("interval");       // "interval" | "all"
  const [ratingScope, setRatingScope] = useState("interval");   // unified scope toggle

  // Interval aggregates based on ratingMode
  const interval = useMemo(() => {
    const jobs = inRange.reduce((a,b)=>a+b.jobs,0);
    let sum = 0;
    inRange.forEach(p => { const avg = ratingMode === "satisfaction" ? p.satisfactionRating : p.customerServiceRating; sum += avg * p.jobs; });
    const avgInterval = jobs ? (sum / jobs) : 0;
    const gainedStars = Math.round(sum);
    const possibleStars = inRange.reduce((a,b)=>a + b.jobs*5,0);
    const dist = intervalStarDistribution(inRange, ratingMode);
    return { jobs, avgInterval, gainedStars, possibleStars, dist };
  }, [inRange, ratingMode]);

  // All-time aggregates
  const allTime = useMemo(() => {
    const jobs = all.reduce((a,b)=>a+b.jobs,0);
    const satSum = all.reduce((a,b)=> a + b.satisfactionRating * b.jobs, 0);
    const svcSum = all.reduce((a,b)=> a + b.customerServiceRating * b.jobs, 0);
    const avgSatisfactionAll = jobs ? satSum / jobs : 0;
    const avgServiceAll = jobs ? svcSum / jobs : 0;
    const abandoned = all.reduce((a,b)=>a+b.abandoned,0);
    const referrals = all.reduce((a,b)=>a+b.referrals,0);
    const rehire    = all.reduce((a,b)=>a+b.rehire,0);
    const possibleStarsAll = all.reduce((a,b)=>a + b.jobs*5,0);
    return {
      jobs,
      avgSatisfactionAll,
      avgServiceAll,
      satSum,
      svcSum,
      possibleStarsAll,
      rates: {
        abandonmentRate: jobs ? (abandoned / jobs) * 100 : 0,
        referralRate:    jobs ? (referrals / jobs) * 100 : 0,
        rehireRate:      jobs ? (rehire    / jobs) * 100 : 0,
      }
    };
  }, [all]);

  // ===== Color maps (no repeats, high contrast). Offset red to look different from green.
  const greenColorMap = useMemo(() => colorMapForTags(GREEN_TAGS, 0), []);
  const redColorMap   = useMemo(() => colorMapForTags(RED_TAGS, 3), []);

  // ===== Tag counts (interval/all) + attach colors =====
  const greenInterval = useMemo(
    () => tagCountsFromWindow(inRange, GREEN_TAGS, 111).map(x => ({ ...x, color: greenColorMap[x.tag] })),
    [inRange, greenColorMap]
  );
  const redInterval = useMemo(
    () => tagCountsFromWindow(inRange, RED_TAGS, 333).map(x => ({ ...x, color: redColorMap[x.tag] })),
    [inRange, redColorMap]
  );
  const greenAll = useMemo(
    () => tagCountsFromWindow(all, GREEN_TAGS, 111).map(x => ({ ...x, color: greenColorMap[x.tag] })),
    [all, greenColorMap]
  );
  const redAll = useMemo(
    () => tagCountsFromWindow(all, RED_TAGS, 333).map(x => ({ ...x, color: redColorMap[x.tag] })),
    [all, redColorMap]
  );

  const activeGreen = tagsScope === "interval" ? greenInterval : greenAll;
  const activeRed   = tagsScope === "interval" ? redInterval   : redAll;

  // === Derived for unified Rating card ===
  const scopeIsInterval = ratingScope === "interval";
  const avgAll = ratingMode === "satisfaction" ? allTime.avgSatisfactionAll : allTime.avgServiceAll;
  const gainedStarsAll = Math.round(ratingMode === "satisfaction" ? allTime.satSum : allTime.svcSum);
  const distAll = useMemo(() => intervalStarDistribution(all, ratingMode), [all, ratingMode]);

  const avgShown = scopeIsInterval ? (interval.avgInterval || 0) : (avgAll || 0);
  const starsEarnedShown = scopeIsInterval ? interval.gainedStars : gainedStarsAll;
  const possibleStarsShown = scopeIsInterval ? interval.possibleStars : allTime.possibleStarsAll;
  const distShown = scopeIsInterval ? interval.dist : distAll;
  const contractsShown = scopeIsInterval ? interval.jobs : allTime.jobs;

  // Rates scope selection
  const activeRates = ratesScope === "interval" ? (() => {
    const jobs = inRange.reduce((a,b)=>a+b.jobs,0);
    const abandoned = inRange.reduce((a,b)=>a+b.abandoned,0);
    const referrals = inRange.reduce((a,b)=>a+b.referrals,0);
    const rehire    = inRange.reduce((a,b)=>a+b.rehire,0);
    return {
      abandonmentRate: jobs ? (abandoned / jobs) * 100 : 0,
      referralRate:    jobs ? (referrals / jobs) * 100 : 0,
      rehireRate:      jobs ? (rehire    / jobs) * 100 : 0,
    };
  })() : allTime.rates;

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor={BLACK} />

      {/* Top bar (no avatar, no menu) */}
      <View style={styles.topBar}>
        <TouchableOpacity style={styles.backBtn} activeOpacity={0.7}>
          <Ionicons name="chevron-back" size={24} color={WHITE} />
        </TouchableOpacity>

        <Text style={styles.topTitle}>Mini Contract Stats</Text>

        <View style={{ width: 40, height: 36 }} />
      </View>

      <View style={styles.topAccent} />

      <ScrollView contentContainerStyle={{ padding: 12, paddingBottom: 24 }}>
        {/* Niche */}
        <Card>
          <TitleRow title="Niche" help="Pick a field. All numbers below use only MINI-CONTRACT data for that field." />
          <View style={styles.nicheRow}>
            {NICHE_KEYS.map((k) => (
              <Chip key={k} text={k} active={niche === k} onPress={() => setNiche(k)} />
            ))}
          </View>
        </Card>

        {/* DATE RANGE */}
        <Card>
          <TitleRow title="Date interval" help="Choose a date window to analyze your mini-contract performance." />
          <View style={styles.rangeRow}>
            <Text style={styles.rangeLbl}>From</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => setStartIdx((s)=>Math.min(endIdx, Math.max(0, s - 1)))}><Ionicons name="chevron-back" size={16} color={BLACK} /></TouchableOpacity>
            <Text style={styles.rangeVal}>{fmt(all[startIdx].date)}</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => setStartIdx((s)=>Math.min(endIdx, Math.max(0, s + 1)))}><Ionicons name="chevron-forward" size={16} color={BLACK} /></TouchableOpacity>
          </View>
          <View style={styles.rangeRow}>
            <Text style={styles.rangeLbl}>To</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => setEndIdx((e)=>Math.max(startIdx, Math.min(all.length - 1, e - 1)))}><Ionicons name="chevron-back" size={16} color={BLACK} /></TouchableOpacity>
            <Text style={styles.rangeVal}>{fmt(all[endIdx].date)}</Text>
            <TouchableOpacity style={styles.arrowBtn} onPress={() => setEndIdx((e)=>Math.max(startIdx, Math.min(all.length - 1, e + 1)))}><Ionicons name="chevron-forward" size={16} color={BLACK} /></TouchableOpacity>
          </View>
        </Card>

        {/* TOGGLE: Satisfaction vs Customer Service */}
        <Card>
          <TitleRow title="Rating Focus" help="Switch between: Satisfaction Rating (job result) and Customer Service Rating (experience)." />
          <View style={styles.toggleRow}>
            <TouchableOpacity style={[styles.toggleBtn, ratingMode === "satisfaction" && styles.toggleActive]} onPress={() => setRatingMode("satisfaction")} activeOpacity={0.9}>
              <Text style={[styles.toggleTxt, ratingMode === "satisfaction" && styles.toggleTxtActive]}>Satisfaction Rating</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[styles.toggleBtn, ratingMode === "service" && styles.toggleActive]} onPress={() => setRatingMode("service")} activeOpacity={0.9}>
              <Text style={[styles.toggleTxt, ratingMode === "service" && styles.toggleTxtActive]}>Customer Service Rating</Text>
            </TouchableOpacity>
          </View>
        </Card>

        {/* === MERGED Rating card with scope toggle === */}
        <Card>
          <TitleRow
            title={ratingMode === "satisfaction" ? "Satisfaction" : "Customer Service"}
            help="Use the toggle to view metrics for the selected date interval or all-time."
          />
          <View style={styles.toggleRow}>
            <TouchableOpacity
              style={[styles.toggleBtn, ratingScope === "interval" && styles.toggleActive]}
              onPress={() => setRatingScope("interval")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, ratingScope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.toggleBtn, ratingScope === "all" && styles.toggleActive]}
              onPress={() => setRatingScope("all")}
              activeOpacity={0.9}
            >
              <Text style={[styles.toggleTxt, ratingScope === "all" && styles.toggleTxtActive]}>All-Time</Text>
            </TouchableOpacity>
          </View>

          <View style={[styles.kpiBlock, { marginTop: 8 }]}>
            <Text style={styles.kpiBlockTitle}>Average Rating</Text>
            <StarMeter value={avgShown} />
            <Text style={[styles.kpiHint, { marginTop: 6 }]}>
              Stars earned: <Text style={styles.bigStatInline}>{starsEarnedShown}</Text> / {possibleStarsShown}
            </Text>
            <Text style={styles.kpiHint}>
              {ratingScope === "interval" ? "Contracts in this interval" : "Total contracts"}:{" "}
              <Text style={styles.bigStatInline}>{contractsShown}</Text>
            </Text>
          </View>

          <View style={[styles.kpiBlock, { marginTop: 8 }]}>
            <Text style={styles.kpiBlockTitle}>Star Distribution</Text>
            <Text style={styles.kidRow}>⭐⭐⭐⭐⭐  =  {distShown[5]}</Text>
            <Text style={styles.kidRow}>⭐⭐⭐⭐    =  {distShown[4]}</Text>
            <Text style={styles.kidRow}>⭐⭐⭐      =  {distShown[3]}</Text>
            <Text style={styles.kidRow}>⭐⭐        =  {distShown[2]}</Text>
            <Text style={styles.kidRow}>⭐          =  {distShown[1]}</Text>
            <Text style={styles.kpiHint}>
              {ratingScope === "interval"
                ? "Counts modeled from daily average and jobs for this window."
                : "Counts modeled from daily average and jobs across all time."}
            </Text>
          </View>
        </Card>

        {/* ===== KEY RATES (360° Gauges) ===== */}
        <Card>
          <TitleRow title="Key Rates" help="Abandonment (lower better), Referral, and Rehire. Toggle for interval vs all-time." />
          <View style={styles.toggleRow}>
            <TouchableOpacity style={[styles.toggleBtn, ratesScope === "interval" && styles.toggleActive]} onPress={() => setRatesScope("interval")} activeOpacity={0.9}>
              <Text style={[styles.toggleTxt, ratesScope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[styles.toggleBtn, ratesScope === "all" && styles.toggleActive]} onPress={() => setRatesScope("all")} activeOpacity={0.9}>
              <Text style={[styles.toggleTxt, ratesScope === "all" && styles.toggleTxtActive]}>All-Time</Text>
            </TouchableOpacity>
          </View>
          <View style={styles.gaugeRow}>
            <GaugeRing label="🚫 Abandonment" pct={activeRates.abandonmentRate} />
            <GaugeRing label="📣 Referral" pct={activeRates.referralRate} />
            <GaugeRing label="🔁 Rehire" pct={activeRates.rehireRate} />
          </View>
        </Card>

        {/* ===== GREEN TAGS (counts + pie + unique colors) ===== */}
        <Card>
          <TitleRow title="Green Tags" help="Top strengths in the selected window (or All-Time via toggle). Colors are all distinct." />
          <View style={styles.toggleRow}>
            <TouchableOpacity style={[styles.toggleBtn, tagsScope === "interval" && styles.toggleActive]} onPress={() => setTagsScope("interval")} activeOpacity={0.9}>
              <Text style={[styles.toggleTxt, tagsScope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[styles.toggleBtn, tagsScope === "all" && styles.toggleActive]} onPress={() => setTagsScope("all")} activeOpacity={0.9}>
              <Text style={[styles.toggleTxt, tagsScope === "all" && styles.toggleTxtActive]}>All-Time</Text>
            </TouchableOpacity>
          </View>

          <View style={styles.pieRow}>
            <PieChart data={activeGreen} size={160} />
            <View style={styles.legendCol}>
              {activeGreen.map((t) => (
                <View key={t.tag} style={styles.legendItem}>
                  <View style={[styles.legendSwatch, { backgroundColor: t.color }]} />
                  <Text style={styles.legendText} numberOfLines={1}>
                    {cap(t.tag)} ({t.count} {t.count === 1 ? "tag" : "tags"})
                  </Text>
                </View>
              ))}
            </View>
          </View>
        </Card>

        {/* ===== RED TAGS (counts + pie + unique colors) ===== */}
        <Card>
          <TitleRow title="Red Tags" help="Risk signals in the selected window (or All-Time via toggle). Colors are all distinct." />
          <View style={styles.toggleRow}>
            <TouchableOpacity style={[styles.toggleBtn, tagsScope === "interval" && styles.toggleActive]} onPress={() => setTagsScope("interval")} activeOpacity={0.9}>
              <Text style={[styles.toggleTxt, tagsScope === "interval" && styles.toggleTxtActive]}>This Interval</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[styles.toggleBtn, tagsScope === "all" && styles.toggleActive]} onPress={() => setTagsScope("all")} activeOpacity={0.9}>
              <Text style={[styles.toggleTxt, tagsScope === "all" && styles.toggleTxtActive]}>All-Time</Text>
            </TouchableOpacity>
          </View>

          <View style={styles.pieRow}>
            <PieChart data={activeRed} size={160} />
            <View style={styles.legendCol}>
              {activeRed.map((t) => (
                <View key={t.tag} style={styles.legendItem}>
                  <View style={[styles.legendSwatch, { backgroundColor: t.color }]} />
                  <Text style={styles.legendText} numberOfLines={1}>
                    {cap(t.tag)} ({t.count})
                  </Text>
                </View>
              ))}
            </View>
          </View>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
}

/* ===== Styles ===== */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: WHITE },

  /* Top bar */
  topBar: {
    backgroundColor: BLACK,
    height: TOP_BAR_HEIGHT,
    paddingTop: Platform.OS === "android" ? (StatusBar.currentHeight || 0) : 12,
    paddingHorizontal: 12,
    paddingBottom: 12,
    flexDirection: "row",
    alignItems: "flex-end",
    justifyContent: "space-between",
  },
  topAccent: { height: TOP_ACCENT, backgroundColor: YELLOW },
  backBtn: { width: 40, height: 36, justifyContent: "center" },
  topTitle: { color: WHITE, fontWeight: "900", fontSize: 18 },

  /* Cards */
  card: { backgroundColor: WHITE, borderWidth: 2, borderColor: BLACK, borderRadius: 14, padding: 12, marginBottom: 12 },
  titleRow: { flexDirection: "row", justifyContent: "space-between", alignItems: "center" },
  cardTitle: { fontSize: 14, fontWeight: "900", color: BLACK },
  infoBtn: { width: 22, height: 22, borderRadius: 11, borderWidth: 2, borderColor: BLACK, alignItems: "center", justifyContent: "center", backgroundColor: WHITE },
  helpBox: { marginTop: 8, borderWidth: 2, borderColor: BLACK, borderRadius: 10, padding: 8, backgroundColor: "#FFFDF2" },
  helpText: { color: BLACK, fontSize: 12 },

  /* Niche row */
  nicheRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  chip: { paddingVertical: 6, paddingHorizontal: 10, borderRadius: 16, borderWidth: 2, borderColor: BLACK, backgroundColor: WHITE },
  chipTxt: { color: BLACK, fontSize: 12, fontWeight: "900" },

  /* Range */
  rangeRow: { flexDirection: "row", alignItems: "center", gap: 8, marginTop: 8 },
  rangeLbl: { width: 38, fontSize: 12, color: BLACK, fontWeight: "900" },
  arrowBtn: { width: 30, height: 28, borderRadius: 8, borderWidth: 2, borderColor: BLACK, alignItems: "center", justifyContent: "center", backgroundColor: WHITE },
  rangeVal: { minWidth: 120, textAlign: "center", borderWidth: 2, borderColor: BLACK, borderRadius: 8, paddingVertical: 4, paddingHorizontal: 8, fontSize: 12, fontWeight: "900", color: BLACK, backgroundColor: "#FFFDF2" },

  /* Toggle */
  toggleRow: { flexDirection: "row", gap: 8, marginTop: 8 },
  toggleBtn: { flex: 1, borderWidth: 2, borderColor: BLACK, borderRadius: 12, paddingVertical: 10, alignItems: "center", backgroundColor: WHITE },
  toggleActive: { backgroundColor: "#FFFDF2", borderColor: YELLOW },
  toggleTxt: { fontSize: 12, fontWeight: "900", color: BLACK, textAlign: "center" },
  toggleTxtActive: { color: BLACK },

  /* KPI blocks */
  kpiBlock: { borderWidth: 2, borderColor: BLACK, borderRadius: 12, padding: 10, backgroundColor: WHITE, marginTop: 8 },
  kpiBlockTitle: { fontSize: 12, color: BLACK, fontWeight: "900", marginBottom: 6 },
  bigStatInline: { fontSize: 16, fontWeight: "900", color: BLACK },
  kpiHint: { fontSize: 11, color: BLACK, opacity: 0.75 },

  /* Star meter */
  starRow: { flexDirection: "row", alignItems: "center", gap: 4 },
  starVal: { marginLeft: 6, fontSize: 16, fontWeight: "900", color: BLACK },

  /* Simple star distribution list */
  kidRow: { fontSize: 14, fontWeight: "900", color: BLACK, marginTop: 4 },

  /* Gauges (360° donut) */
  gaugeRow: { flexDirection: "row", justifyContent: "space-around", marginTop: 12, flexWrap: "wrap" },
  gaugeWrap: { alignItems: "center", marginVertical: 8 },
  gaugeBox: { justifyContent: "center", alignItems: "center" },
  gaugeTrack: { position: "absolute", borderColor: "#E0E0E0", backgroundColor: "transparent" },
  halfWrap: { position: "absolute", overflow: "hidden" },
  arc: { position: "absolute", borderColor: YELLOW, backgroundColor: "transparent" },
  gaugeHole: { position: "absolute", backgroundColor: WHITE, alignItems: "center", justifyContent: "center" },
  gaugePct: { fontSize: 16, fontWeight: "900", color: BLACK },
  gaugeLabel: { marginTop: 6, fontSize: 12, fontWeight: "900", color: BLACK, textAlign: "center" },

  /* Pie + legend */
  pieRow: { flexDirection: "row", gap: 12, alignItems: "center", marginTop: 10 },
  legendCol: { flex: 1, gap: 6 },
  legendItem: { flexDirection: "row", alignItems: "center", gap: 8 },
  legendSwatch: { width: 14, height: 14, borderRadius: 3, borderWidth: 1.5, borderColor: BLACK },
  legendText: { fontSize: 12, color: BLACK, fontWeight: "900", flexShrink: 1 },
});
